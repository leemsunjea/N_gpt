import os
import json
import numpy as np
from sqlalchemy import select
from database import async_session, DocumentChunk
import asyncio

# 임베딩 모델이 없을 때 사용할 간단한 대체 클래스
class DummyEmbedder:
    def encode(self, texts):
        # 384차원의 랜덤 임베딩 생성
        return np.random.rand(len(texts), 384).astype('float32')

# 더 가벼운 임베딩 서비스
class LightweightEmbeddingService:
    def __init__(self):
        # 인덱스 파일 경로
        self.index_path = "faiss_index.bin"
        self.chunk_ids_path = "chunk_ids.json"
        self.dimension = 384  # 임베딩 차원
        
        # 필요한 모듈들은 메서드 내에서 필요할 때만 로드
        self._model = None
        self._faiss = None
        self.index = None
        self.chunk_ids = []
        
        # 환경 변수 확인 - CloudType 배포 여부
        self.is_cloudtype = os.environ.get('CLOUDTYPE_DEPLOYMENT', '0') == '1'
        
    def _load_faiss(self):
        """필요할 때만 FAISS 모듈 로드"""
        if self._faiss is None:
            try:
                import faiss
                self._faiss = faiss
                # FAISS 인덱스 초기화 또는 로드
                self.load_index()
            except ImportError:
                print("FAISS 모듈 설치 필요. CloudType 환경에서는 대체 검색 구현 사용")
                # CloudType 환경에서는 간단한 인메모리 검색 로직 사용
                self._faiss = None
                self.index = {"vectors": [], "ids": []}
    
    def _load_model(self):
        """필요할 때만 임베딩 모델 로드"""
        if self._model is None:
            try:
                from sentence_transformers import SentenceTransformer
                self._model = SentenceTransformer('paraphrase-MiniLM-L3-v2')
            except ImportError:
                print("SentenceTransformer 모듈 설치 필요. CloudType 환경에서는 간단한 임베딩 사용")
                # CloudType 환경에서는 간단한 임베딩 대체 로직 사용
                self._model = DummyEmbedder()
    
    def load_index(self):
        """기존 FAISS 인덱스 로드"""
        if self.is_cloudtype:
            # CloudType 환경에서는 간단한 인메모리 저장소 사용
            self.index = {"vectors": [], "ids": []}
            self.chunk_ids = []
            return
            
        try:
            if self._faiss is None:
                self._load_faiss()
                
            if self._faiss and os.path.exists(self.index_path):
                self.index = self._faiss.read_index(self.index_path)
                print(f"FAISS 인덱스 로드됨: {self.index.ntotal}개 벡터")
            elif self._faiss:
                self.index = self._faiss.IndexFlatIP(self.dimension)
            
            if os.path.exists(self.chunk_ids_path):
                with open(self.chunk_ids_path, 'r') as f:
                    self.chunk_ids = json.load(f)
                print(f"청크 ID 로드됨: {len(self.chunk_ids)}개")
        except Exception as e:
            print(f"인덱스 로드 실패: {e}")
            if self._faiss:
                self.index = self._faiss.IndexFlatIP(self.dimension)
            else:
                self.index = {"vectors": [], "ids": []}
            self.chunk_ids = []
    
    def save_index(self):
        """FAISS 인덱스 저장"""
        if self.is_cloudtype:
            # CloudType 환경에서는 저장하지 않음
            return
            
        if self.index is None:
            print("저장할 인덱스가 없습니다.")
            return
            
        try:
            if self._faiss:
                self._faiss.write_index(self.index, self.index_path)
                with open(self.chunk_ids_path, 'w') as f:
                    json.dump(self.chunk_ids, f)
                print("FAISS 인덱스 저장 완료")
        except Exception as e:
            print(f"인덱스 저장 실패: {e}")
    
    def create_embedding(self, text):
        """텍스트를 임베딩으로 변환"""
        self._load_model()  # 임베딩 모델 로드
        
        if self._model is None:
            # 간단한 대체 임베딩 생성 (실제 유사도 검색에는 적합하지 않음)
            return np.random.rand(self.dimension).astype('float32')
            
        embedding = self._model.encode([text])
        
        # L2 정규화 (코사인 유사도를 위해)
        if self._faiss:
            self._load_faiss()
            self._faiss.normalize_L2(embedding.astype('float32'))
        else:
            # 수동으로 L2 정규화
            norm = np.linalg.norm(embedding[0])
            if norm > 0:
                embedding[0] = embedding[0] / norm
                
        return embedding[0]
    
    def add_to_index(self, chunk_id, text):
        """FAISS 인덱스에 텍스트 추가"""
        try:
            embedding = self.create_embedding(text)
            
            if self.is_cloudtype:
                # CloudType 환경에서는 간단한 인메모리 저장소 사용
                if isinstance(self.index, dict):
                    self.index["vectors"].append(embedding)
                    self.index["ids"].append(chunk_id)
                self.chunk_ids.append(chunk_id)
                return embedding.tolist()
                
            # FAISS 인덱스 사용
            self._load_faiss()  # FAISS 모듈 로드
            
            if self._faiss and self.index is None:
                self.index = self._faiss.IndexFlatIP(self.dimension)
                
            if self._faiss:
                self.index.add(embedding.reshape(1, -1).astype('float32'))
                self.chunk_ids.append(chunk_id)
            
            print(f"인덱스에 추가됨: chunk_id={chunk_id}")
            return embedding.tolist()
        except Exception as e:
            print(f"인덱스 추가 실패: {e}")
            return None

    async def search_similar(self, query, k=5):
        """유사한 문서 청크 검색"""
        try:
            # 쿼리 임베딩 생성
            query_embedding = self.create_embedding(query)
            
            if self.is_cloudtype or self._faiss is None:
                # CloudType 환경에서는 간단한 인메모리 검색 사용
                results = []
                
                if not isinstance(self.index, dict) or not self.index["vectors"]:
                    return []
                    
                # 간단한 코사인 유사도 계산
                scores = []
                for vec in self.index["vectors"]:
                    dot_product = np.dot(query_embedding, vec)
                    scores.append(dot_product)
                
                # 상위 k개 인덱스 찾기
                if not scores:
                    return []
                    
                top_indices = np.argsort(scores)[-k:][::-1]
                top_scores = [scores[i] for i in top_indices]
                
                # 결과 처리
                async with async_session() as session:
                    for i, (idx, score) in enumerate(zip(top_indices, top_scores)):
                        if 0 <= idx < len(self.index["ids"]):
                            chunk_id = self.index["ids"][idx]
                            
                            # 데이터베이스에서 청크 정보 조회
                            stmt = select(DocumentChunk).where(DocumentChunk.id == chunk_id)
                            result = await session.execute(stmt)
                            chunk = result.scalar_one_or_none()
                            
                            if chunk:
                                results.append({
                                    'chunk_id': chunk_id,
                                    'text': chunk.chunk_text,
                                    'score': float(score),
                                    'document_id': chunk.document_id
                                })
                
                return results
            
            # FAISS 사용 검색
            self._load_faiss()  # FAISS 모듈 로드
            
            # FAISS에서 검색
            scores, indices = self.index.search(
                query_embedding.reshape(1, -1).astype('float32'), k
            )
            
            # 결과 처리
            results = []
            async with async_session() as session:
                for i, (score, idx) in enumerate(zip(scores[0], indices[0])):
                    if idx >= 0 and idx < len(self.chunk_ids):
                        chunk_id = self.chunk_ids[idx]
                        
                        # 데이터베이스에서 청크 정보 조회
                        stmt = select(DocumentChunk).where(DocumentChunk.id == chunk_id)
                        result = await session.execute(stmt)
                        chunk = result.scalar_one_or_none()
                        
                        if chunk:
                            results.append({
                                'chunk_id': chunk_id,
                                'text': chunk.chunk_text,
                                'score': float(score),
                                'document_id': chunk.document_id
                            })
            
            return results
        except Exception as e:
            print(f"검색 실패: {e}")
            return []

# 전역 임베딩 서비스 인스턴스
embedding_service = LightweightEmbeddingService()
